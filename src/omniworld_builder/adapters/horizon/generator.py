"""Meta Horizon Worlds TypeScript code generator for WDL worlds."""

from pathlib import Path
from textwrap import dedent

from omniworld_builder.adapters.base import BaseAdapter
from omniworld_builder.core.wdl_schema import (
    EntityType,
    Lighting,
    LightType,
    WDLEntity,
    WDLWorld,
)


class HorizonGenerator(BaseAdapter):
    """Generator for Meta Horizon Worlds TypeScript scripts from WDL worlds."""

    def __init__(self, output_dir: str | Path = "horizon_output") -> None:
        """Initialize the Horizon generator."""
        super().__init__(output_dir)

    @property
    def platform_name(self) -> str:
        """Get the platform name."""
        return "horizon"

    @property
    def file_extension(self) -> str:
        """Get the file extension."""
        return ".ts"

    def generate(self, world: WDLWorld) -> dict[str, str]:
        """Generate Horizon TypeScript code from a WDL world.

        Args:
            world: The WDL world to generate code for.

        Returns:
            Dictionary mapping file paths to TypeScript code content.
        """
        files: dict[str, str] = {}

        # Generate main world script
        files["scripts/WorldManager.ts"] = self._generate_world_manager(world)

        # Generate entity factory
        files["scripts/EntityFactory.ts"] = self._generate_entity_factory(world)

        # Generate environment controller
        files["scripts/EnvironmentController.ts"] = self._generate_environment_controller(world)

        # Generate types
        files["scripts/types.ts"] = self._generate_types()

        # Generate world data
        files["data/worldData.ts"] = self._generate_world_data(world)

        # Generate JSON data file
        files["data/world_data.json"] = world.to_json()

        return files

    def _generate_world_manager(self, world: WDLWorld) -> str:
        """Generate the main world manager script."""
        return dedent(f'''
            /**
             * Auto-generated Horizon Worlds world manager.
             * World: {world.metadata.title}
             * Description: {world.metadata.description}
             * Generated by OmniWorld Builder
             */

            import {{ Component, Entity, World, PropTypes, Player }} from 'horizon/core';
            import {{ EntityFactory }} from './EntityFactory';
            import {{ EnvironmentController }} from './EnvironmentController';
            import {{ WorldData }} from '../data/worldData';

            /**
             * Main world manager component that orchestrates world building.
             */
            class WorldManager extends Component {{
              static propsDefinition = {{
                autoLoad: {{ type: PropTypes.Boolean, default: true }},
              }};

              private entityFactory: EntityFactory;
              private environmentController: EnvironmentController;
              private spawnedEntities: Entity[] = [];

              constructor() {{
                super();
                this.entityFactory = new EntityFactory();
                this.environmentController = new EnvironmentController();
              }}

              start(): void {{
                console.log(`Initializing world: ${{WorldData.metadata.title}}`);

                if (this.props.autoLoad) {{
                  this.loadWorld();
                }}
              }}

              /**
               * Load and build the complete world.
               */
              async loadWorld(): Promise<void> {{
                console.log('Loading world...');

                // Setup environment
                await this.environmentController.setup();

                // Spawn all entities
                this.spawnedEntities = await this.entityFactory.spawnAll();

                console.log(`World loaded! Spawned ${{this.spawnedEntities.length}} entities`);
              }}

              /**
               * Unload and clear the world.
               */
              unloadWorld(): void {{
                console.log('Unloading world...');

                for (const entity of this.spawnedEntities) {{
                  entity.destroy();
                }}
                this.spawnedEntities = [];

                console.log('World unloaded');
              }}

              /**
               * Get all spawned entities.
               */
              getEntities(): Entity[] {{
                return [...this.spawnedEntities];
              }}

              /**
               * Find entity by name.
               */
              findEntityByName(name: string): Entity | undefined {{
                return this.spawnedEntities.find(e => e.name.get() === name);
              }}
            }}

            Component.register(WorldManager);
            export {{ WorldManager }};
        ''').strip()

    def _generate_entity_factory(self, world: WDLWorld) -> str:
        """Generate the entity factory script."""
        entity_entries = []
        for entity in world.entities:
            entry = self._format_entity_entry(entity)
            entity_entries.append(entry)

        entities_str = ",\n  ".join(entity_entries) if entity_entries else ""

        return dedent(f'''
            /**
             * Entity factory for spawning world entities.
             * Total entities: {len(world.entities)}
             */

            import {{ Entity, World, Vec3 }} from 'horizon/core';
            import {{ EntityData, EntityType }} from './types';

            /**
             * Pre-defined entity data for the world.
             */
            export const ENTITY_DATA: EntityData[] = [
              {entities_str}
            ];

            /**
             * Factory class for creating entities in Horizon Worlds.
             */
            export class EntityFactory {{
              private world: World;

              constructor() {{
                this.world = World.getWorld();
              }}

              /**
               * Spawn all entities from the data list.
               */
              async spawnAll(): Promise<Entity[]> {{
                const spawned: Entity[] = [];

                for (const data of ENTITY_DATA) {{
                  const entity = await this.spawnEntity(data);
                  if (entity) {{
                    spawned.push(entity);
                  }}
                }}

                console.log(`Spawned ${{spawned.length}} entities`);
                return spawned;
              }}

              /**
               * Spawn a single entity from data.
               */
              async spawnEntity(data: EntityData): Promise<Entity | null> {{
                try {{
                  const entity = await this.world.spawnEntity({{
                    position: new Vec3(data.position.x, data.position.y, data.position.z),
                    rotation: new Vec3(data.rotation.x, data.rotation.y, data.rotation.z),
                    scale: new Vec3(data.scale.x, data.scale.y, data.scale.z),
                  }});

                  if (entity) {{
                    entity.name.set(data.name);

                    // Set up based on entity type
                    this.configureEntity(entity, data);

                    console.log(`Spawned: ${{data.name}}`);
                  }}

                  return entity;
                }} catch (error) {{
                  console.error(`Failed to spawn ${{data.name}}:`, error);
                  return null;
                }}
              }}

              /**
               * Configure entity based on its type.
               */
              private configureEntity(entity: Entity, data: EntityData): void {{
                switch (data.entityType) {{
                  case EntityType.StaticMesh:
                    // Configure as static mesh
                    break;
                  case EntityType.DynamicObject:
                    // Enable physics
                    break;
                  case EntityType.Trigger:
                    // Setup trigger zone
                    break;
                  case EntityType.SpawnPoint:
                    // Mark as spawn point
                    break;
                  default:
                    break;
                }}
              }}

              /**
               * Spawn entity by ID from the data list.
               */
              async spawnById(id: string): Promise<Entity | null> {{
                const data = ENTITY_DATA.find(e => e.id === id);
                if (data) {{
                  return this.spawnEntity(data);
                }}
                console.warn(`Entity not found: ${{id}}`);
                return null;
              }}
            }}
        ''').strip()

    def _format_entity_entry(self, entity: WDLEntity) -> str:
        """Format a single entity as TypeScript initialization code."""
        pos = entity.transform.position
        rot = entity.transform.rotation
        scale = entity.transform.scale
        tags = ", ".join(f'"{t}"' for t in entity.tags) if entity.tags else ""
        asset_ref = f'"{entity.asset_reference}"' if entity.asset_reference else "undefined"
        entity_type = self._get_horizon_entity_type(entity.entity_type)

        return f'''{{
    id: "{entity.id}",
    name: "{entity.name}",
    entityType: EntityType.{entity_type},
    position: {{ x: {pos.x}, y: {pos.y}, z: {pos.z} }},
    rotation: {{ x: {rot.x}, y: {rot.y}, z: {rot.z} }},
    scale: {{ x: {scale.x}, y: {scale.y}, z: {scale.z} }},
    tags: [{tags}],
    assetReference: {asset_ref},
  }}'''

    def _get_horizon_entity_type(self, entity_type: EntityType) -> str:
        """Convert WDL entity type to Horizon type name."""
        mapping = {
            EntityType.STATIC_MESH: "StaticMesh",
            EntityType.DYNAMIC_OBJECT: "DynamicObject",
            EntityType.CHARACTER: "Character",
            EntityType.PROP: "Prop",
            EntityType.TRIGGER: "Trigger",
            EntityType.SPAWN_POINT: "SpawnPoint",
            EntityType.WAYPOINT: "Waypoint",
            EntityType.LIGHT: "Light",
            EntityType.CAMERA: "Camera",
            EntityType.AUDIO_SOURCE: "AudioSource",
            EntityType.PARTICLE_SYSTEM: "ParticleSystem",
            EntityType.TERRAIN: "Terrain",
        }
        return mapping.get(entity_type, "StaticMesh")

    def _generate_environment_controller(self, world: WDLWorld) -> str:
        """Generate the environment controller script."""
        env = world.environment
        ambient = env.ambient_light

        light_entries = []
        for light in world.lights:
            entry = self._format_light_entry(light)
            light_entries.append(entry)

        lights_str = ",\n  ".join(light_entries) if light_entries else ""

        return dedent(f'''
            /**
             * Environment controller for world settings and lighting.
             * Weather: {env.weather.value}
             * Time: {env.time_of_day.hour}:{env.time_of_day.minute:02d}
             */

            import {{ World, Vec3, Color }} from 'horizon/core';
            import {{ LightData, LightType }} from './types';

            /**
             * Environment configuration.
             */
            export const ENVIRONMENT_CONFIG = {{
              weather: "{env.weather.value}",
              timeOfDay: {{
                hour: {env.time_of_day.hour},
                minute: {env.time_of_day.minute},
                dayNightCycle: {str(env.time_of_day.day_night_cycle).lower()},
              }},
              ambientColor: {{ r: {ambient.r}, g: {ambient.g}, b: {ambient.b}, a: {ambient.a} }},
              fogEnabled: {str(env.fog_enabled).lower()},
              fogColor: {{ r: {env.fog_color.r}, g: {env.fog_color.g}, b: {env.fog_color.b}, a: 1 }},
              fogDensity: {env.fog_density},
              skyboxType: "{env.skybox.skybox_type}",
            }};

            /**
             * Light data for the world.
             */
            export const LIGHT_DATA: LightData[] = [
              {lights_str}
            ];

            /**
             * Controller for environment and lighting settings.
             */
            export class EnvironmentController {{
              private world: World;

              constructor() {{
                this.world = World.getWorld();
              }}

              /**
               * Setup complete environment.
               */
              async setup(): Promise<void> {{
                console.log('Setting up environment...');

                this.setupAmbientLighting();
                this.setupFog();
                await this.createLights();

                console.log('Environment setup complete');
              }}

              /**
               * Configure ambient lighting.
               */
              private setupAmbientLighting(): void {{
                const {{ ambientColor }} = ENVIRONMENT_CONFIG;
                // Horizon-specific ambient light setup
                console.log(`Ambient light: R${{ambientColor.r}} G${{ambientColor.g}} B${{ambientColor.b}}`);
              }}

              /**
               * Configure fog settings.
               */
              private setupFog(): void {{
                if (!ENVIRONMENT_CONFIG.fogEnabled) {{
                  return;
                }}

                const {{ fogColor, fogDensity }} = ENVIRONMENT_CONFIG;
                // Horizon-specific fog setup
                console.log(`Fog enabled: density=${{fogDensity}}`);
              }}

              /**
               * Create all lights in the world.
               */
              private async createLights(): Promise<void> {{
                for (const lightData of LIGHT_DATA) {{
                  await this.createLight(lightData);
                }}
                console.log(`Created ${{LIGHT_DATA.length}} lights`);
              }}

              /**
               * Create a single light.
               */
              private async createLight(data: LightData): Promise<void> {{
                try {{
                  // Horizon-specific light creation
                  console.log(`Creating light: ${{data.name}} (${{data.lightType}})`);
                }} catch (error) {{
                  console.error(`Failed to create light ${{data.name}}:`, error);
                }}
              }}
            }}
        ''').strip()

    def _format_light_entry(self, light: Lighting) -> str:
        """Format a single light as TypeScript initialization code."""
        pos = light.transform.position
        rot = light.transform.rotation
        light_type = self._get_horizon_light_type(light.light_type)

        return f'''{{
    name: "{light.name}",
    lightType: LightType.{light_type},
    color: {{ r: {light.color.r}, g: {light.color.g}, b: {light.color.b}, a: 1 }},
    intensity: {light.intensity},
    position: {{ x: {pos.x}, y: {pos.y}, z: {pos.z} }},
    rotation: {{ x: {rot.x}, y: {rot.y}, z: {rot.z} }},
    castShadows: {str(light.cast_shadows).lower()},
  }}'''

    def _get_horizon_light_type(self, light_type: LightType) -> str:
        """Convert WDL light type to Horizon type name."""
        mapping = {
            LightType.DIRECTIONAL: "Directional",
            LightType.POINT: "Point",
            LightType.SPOT: "Spot",
            LightType.AREA: "Area",
            LightType.AMBIENT: "Ambient",
        }
        return mapping.get(light_type, "Point")

    def _generate_types(self) -> str:
        """Generate TypeScript type definitions."""
        return dedent('''
            /**
             * Type definitions for OmniWorld Builder Horizon integration.
             */

            /**
             * 3D Vector type.
             */
            export interface Vector3 {
              x: number;
              y: number;
              z: number;
            }

            /**
             * RGBA Color type.
             */
            export interface Color {
              r: number;
              g: number;
              b: number;
              a: number;
            }

            /**
             * Entity types supported in Horizon.
             */
            export enum EntityType {
              StaticMesh = 'static_mesh',
              DynamicObject = 'dynamic_object',
              Character = 'character',
              Prop = 'prop',
              Trigger = 'trigger',
              SpawnPoint = 'spawn_point',
              Waypoint = 'waypoint',
              Light = 'light',
              Camera = 'camera',
              AudioSource = 'audio_source',
              ParticleSystem = 'particle_system',
              Terrain = 'terrain',
            }

            /**
             * Light types supported in Horizon.
             */
            export enum LightType {
              Directional = 'directional',
              Point = 'point',
              Spot = 'spot',
              Area = 'area',
              Ambient = 'ambient',
            }

            /**
             * Entity data structure.
             */
            export interface EntityData {
              id: string;
              name: string;
              entityType: EntityType;
              position: Vector3;
              rotation: Vector3;
              scale: Vector3;
              tags: string[];
              assetReference?: string;
            }

            /**
             * Light data structure.
             */
            export interface LightData {
              name: string;
              lightType: LightType;
              color: Color;
              intensity: number;
              position: Vector3;
              rotation: Vector3;
              castShadows: boolean;
            }

            /**
             * World metadata.
             */
            export interface WorldMetadata {
              title: string;
              description: string;
              author: string;
              version: string;
              tags: string[];
              targetPlatforms: string[];
            }
        ''').strip()

    def _generate_world_data(self, world: WDLWorld) -> str:
        """Generate world data TypeScript module."""
        tags = ", ".join(f'"{t}"' for t in world.metadata.tags) if world.metadata.tags else ""
        platforms = (
            ", ".join(f'"{p}"' for p in world.metadata.target_platforms)
            if world.metadata.target_platforms
            else ""
        )

        return dedent(f'''
            /**
             * World data for: {world.metadata.title}
             * Generated by OmniWorld Builder
             */

            import {{ WorldMetadata }} from '../scripts/types';

            /**
             * World metadata.
             */
            export const WorldData = {{
              metadata: {{
                title: "{world.metadata.title}",
                description: "{world.metadata.description}",
                author: "{world.metadata.author}",
                version: "{world.metadata.version}",
                tags: [{tags}],
                targetPlatforms: [{platforms}],
              }} as WorldMetadata,

              bounds: {{
                min: {{ x: {world.bounds.min_bounds.x}, y: {world.bounds.min_bounds.y}, z: {world.bounds.min_bounds.z} }},
                max: {{ x: {world.bounds.max_bounds.x}, y: {world.bounds.max_bounds.y}, z: {world.bounds.max_bounds.z} }},
              }},

              statistics: {{
                entityCount: {len(world.entities)},
                lightCount: {len(world.lights)},
                systemCount: {len(world.systems)},
              }},
            }};
        ''').strip()
